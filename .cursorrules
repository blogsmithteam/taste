1. General Guidelines
Focus: Provide the simplest and most effective solution without unnecessary complexity.

Feature Preservation:
‚ö†Ô∏è CRITICAL: Never modify or remove established features without explicit approval
- Always analyze existing functionality before suggesting changes
- Document and understand current feature behavior before modifications
- Preserve existing API contracts and interfaces
- Maintain backward compatibility unless explicitly approved for breaking changes
- If a feature exists, extend it rather than replace it

Explain Risks: Cursor should clearly warn about potential issues before suggesting changes.

Warn About Dependencies: If a change impacts other files, Cursor should highlight dependencies and risks.

2. Code Suggestions
Avoid:
- Deprecated methods
- Hallucinated version numbers
- Complex state management when simpler solutions suffice
- Over-engineering of features
- Modifying established features without thorough understanding
- Breaking existing functionality
- Changing working code without clear benefits

Version Control:
- Validate version numbers before suggesting them
- Source versions from official documentation (e.g., npm, MDN, framework docs)
- Use semantic versioning for all dependencies
- Document version compatibility with existing features

Enforce Best Practices:
- Follow React and TypeScript best practices
- Implement proper error boundaries
- Use proper type definitions
- Follow accessibility guidelines (WCAG 2.1)

Prioritize Technologies:
‚úÖ React 18+ with TypeScript
‚úÖ Tailwind CSS (preferred over Material-UI for flexibility)
‚úÖ Firebase (Auth, Firestore, Storage)
‚úÖ React Router v6
‚úÖ Context API (preferred over Redux unless complexity demands it)

3. File Changes & Scope Control
Limit Scope:
- Changes should be limited to the requested file unless explicitly approved
- Document all file dependencies in comments
- Keep components focused and single-responsibility
- Never modify core features without explicit approval
- Preserve existing component interfaces
- Maintain backward compatibility

Change Protection:
üõ°Ô∏è Protected Areas (Require Explicit Approval):
- Core feature logic
- Established user flows
- Data models and schemas
- API interfaces
- Authentication flows
- Performance-critical code
- Security-related code

Require Explicit Approval:
- Cursor should not modify related files unless confirmed
- Database schema changes require explicit approval
- Security rule changes require explicit approval
- Changes to established features require explicit approval
- API interface modifications require explicit approval
- Changes affecting user data require explicit approval

Warn About Cascading Effects:
- If a change could break dependencies, explain potential risks
- Highlight performance implications of changes
- Note any security implications

4. Logging & Documentation
Changelog (CHANGELOG.md):
Enabled: ‚úÖ Yes
Purpose: 
- Tracks new features and significant changes
- Documents breaking changes
- Lists security updates

How-To Guide (HOWTO.md):
Enabled: ‚úÖ Yes
Purpose:
- Documents AI-generated features
- Provides setup instructions
- Lists common troubleshooting steps

5. Security & Risk Awareness
üîç General Security Best Practices
- Follow Firebase security best practices
- Implement proper authentication flows
- Use environment variables for sensitive data
- Validate all user input
- Sanitize data before display
- Implement proper CORS policies
- Use secure session management

üîí Data Protection
When handling user data:
‚úÖ Secure authentication with Firebase Auth
‚úÖ Implement proper Firestore security rules
‚úÖ Encrypt sensitive data at rest
‚úÖ Use secure file upload validation
‚úÖ Implement rate limiting
‚úÖ Regular security audits

When handling user-generated content:
‚úÖ Sanitize HTML input
‚úÖ Validate file uploads
‚úÖ Implement proper access controls
‚úÖ Use parameterized queries
‚úÖ Apply content moderation

üõ† Risk Assessment
Before applying changes:
- Assess impact on existing code
- Identify security risks
- Consider performance implications
- Evaluate accessibility impact
- Document potential impact on established features
- Verify backward compatibility
- Test integration with existing functionality

Risk Levels:
üü¢ Low: No security risk, minimal impact, no effect on established features
üü° Medium: Possible risks, review recommended, minor impact on established features
üî¥ High: Significant security concern, manual review required, major impact on established features
‚ö´ Critical: Changes to core functionality, requires extensive testing and explicit approval

6. Project-Specific Rules
Tasting Notes App Requirements:
- Maintain consistent data structure with defined interfaces
- Implement proper error handling for offline scenarios
- Ensure responsive design for all components
- Follow mobile-first approach
- Implement proper image optimization
- Use proper caching strategies
- Maintain consistent naming conventions
- Document all API endpoints
- Include proper TypeScript types
- Follow React component best practices

7. Performance Guidelines
- Optimize bundle size
- Implement proper code splitting
- Use proper caching strategies
- Optimize images and assets
- Monitor performance metrics
- Implement proper loading states
- Use proper error boundaries
- Optimize database queries
- Implement proper pagination
- Use proper lazy loading

8. Testing Requirements
- Write unit tests for critical components
- Implement integration tests
- Use proper test coverage
- Follow testing best practices
- Document test cases
- Implement proper mocking
- Use proper test utilities
- Follow proper test naming conventions
- Implement proper test isolation
- Use proper test data management